<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>Rust 2D: Global Update</title>
<style>
    body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', sans-serif; user-select: none; }
    canvas { display: block; }

    /* UI Layers */
    #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    .pointer { pointer-events: auto; }

    /* HUD */
    #hud { position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 8px; }
    .bar { width: 220px; height: 20px; background: rgba(0,0,0,0.6); border: 2px solid #555; border-radius: 4px; overflow: hidden; position: relative; }
    .fill { height: 100%; transition: width 0.2s; }
    .bar-text { position: absolute; right: 5px; top: 0; font-size: 12px; color: white; font-weight: bold; line-height: 20px; text-shadow: 1px 1px 0 #000; }

    /* Hotbar */
    #hotbar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; }
    .slot { 
        width: 60px; height: 60px; background: rgba(40,40,40,0.85); border: 2px solid #555; 
        color: white; display: flex; flex-direction: column; align-items: center; justify-content: center;
        font-size: 10px; cursor: pointer; position: relative; transition: 0.1s;
    }
    .slot:hover { background: rgba(60,60,60,0.9); }
    .slot.active { border-color: #76ff03; box-shadow: 0 0 10px rgba(118, 255, 3, 0.3); transform: translateY(-5px); }
    .slot-icon { font-size: 24px; }
    .slot-count { position: absolute; bottom: 2px; right: 4px; font-weight: bold; font-size: 12px; color: #ddd; }

    /* Menus (Inventory, Craft, Main) */
    .menu-overlay { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); 
        display: none; justify-content: center; align-items: center; z-index: 50; pointer-events: auto;
    }
    .panel { 
        background: #2d2d2d; border: 1px solid #555; padding: 20px; color: #eee; border-radius: 5px; 
        box-shadow: 0 10px 30px rgba(0,0,0,0.8); display: flex; gap: 20px; max-height: 80vh;
    }
    
    /* Crafting Tabs */
    .tabs { display: flex; gap: 5px; margin-bottom: 10px; }
    .tab { padding: 5px 10px; background: #444; cursor: pointer; border-radius: 3px; font-size: 12px; }
    .tab.active-tab { background: #76ff03; color: #000; font-weight: bold; }
    
    .scroll-list { overflow-y: auto; max-height: 400px; padding-right: 5px; width: 300px; }
    .craft-row { 
        display: flex; align-items: center; justify-content: space-between; background: #383838; 
        margin-bottom: 5px; padding: 8px; cursor: pointer; border: 1px solid #444; 
    }
    .craft-row:hover { background: #444; border-color: #888; }
    .locked { opacity: 0.5; cursor: not-allowed; }

    /* Building Radial Menu (Simulated) */
    #build-menu {
        position: absolute; display: none; background: rgba(20,20,20,0.95);
        border: 2px solid #76ff03; border-radius: 50%; width: 200px; height: 200px;
        z-index: 20; pointer-events: auto;
    }
    .build-opt {
        position: absolute; width: 50px; height: 50px; background: #444; border-radius: 50%;
        display: flex; justify-content: center; align-items: center; font-size: 20px; cursor: pointer;
        border: 2px solid #555; color: white; box-shadow: 0 0 5px black;
    }
    .build-opt:hover { background: #76ff03; color: black; border-color: white; }
    /* Positioning options in a circle */
    .b-center { top: 75px; left: 75px; background: #333; font-size: 12px; } /* Cancel */
    .b-top { top: 10px; left: 75px; } /* Foundation */
    .b-right { top: 75px; left: 140px; } /* Wall */
    .b-bottom { top: 140px; left: 75px; } /* DoorFrame */
    .b-left { top: 75px; left: 10px; } /* Triangle */
    .b-tr { top: 30px; left: 120px; } /* Roof */

    /* Start Screen */
    #main-menu { display: flex; flex-direction: column; gap: 15px; text-align: center; }
    .btn { padding: 15px 40px; font-size: 18px; background: #76ff03; border: none; cursor: pointer; font-weight: bold; color: #111; text-transform: uppercase; letter-spacing: 1px; }
    .btn:hover { background: #64dd17; transform: scale(1.05); }
    .btn-sec { background: #555; color: white; }
    .btn-sec:hover { background: #777; }

    /* Notifications */
    #notify-area { position: absolute; bottom: 120px; right: 20px; display: flex; flex-direction: column; gap: 5px; align-items: flex-end; }
    .note { background: rgba(0,0,0,0.8); color: #fff; padding: 5px 12px; border-right: 4px solid #76ff03; font-size: 14px; animation: fadeOut 4s forwards; }
    @keyframes fadeOut { 0% {opacity:1;} 80% {opacity:1;} 100% {opacity:0;} }
</style>
</head>
<body>

<canvas id="cvs"></canvas>

<div id="start-screen" class="menu-overlay" style="display: flex;">
    <div id="main-menu">
        <h1 style="color: #76ff03; font-size: 70px; margin: 0; text-shadow: 0 0 20px #76ff03;">RUST 2D</h1>
        <p style="color: #aaa;">SURVIVAL ‚Ä¢ CRAFT ‚Ä¢ RAID</p>
        <button class="btn" onclick="initGame(false)">–ü–†–û–î–û–õ–ñ–ò–¢–¨</button>
        <button class="btn btn-sec" onclick="initGame(true)">–ù–û–í–ê–Ø –ò–ì–†–ê</button>
        <div style="font-size: 12px; color: #666; margin-top: 20px;">
            WASD - –†—É—Ö | E - –Ü–Ω–≤–µ–Ω—Ç–∞—Ä | –ü–ö–ú (Build Plan) - –ú–µ–Ω—é –±—É–¥–æ–≤–∏<br>
            –õ–ö–ú - –î—ñ—è | G - –ö–∞—Ä—Ç–∞
        </div>
    </div>
</div>

<div id="ui-layer">
    <div id="notify-area"></div>
    
    <div id="hud">
        <div class="bar"><div class="fill" id="hp-bar" style="background:#d32f2f; width:100%"></div><span class="bar-text">HP</span></div>
        <div class="bar"><div class="fill" id="food-bar" style="background:#f57c00; width:100%"></div><span class="bar-text">FOOD</span></div>
    </div>
    
    <div id="hotbar" class="pointer"></div>
</div>

<div id="game-menu" class="menu-overlay">
    <div class="panel">
        <div style="width: 320px;">
            <h3 style="margin-top:0">–†—é–∫–∑–∞–∫</h3>
            <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px;" id="inv-grid"></div>
        </div>
        <div style="width: 350px; border-left: 1px solid #444; padding-left: 20px;">
            <h3 style="margin-top:0">–ö—Ä–∞—Ñ—Ç</h3>
            <div class="tabs" id="craft-tabs"></div>
            <div class="scroll-list" id="craft-list"></div>
            <div id="craft-req" style="margin-top: 10px; font-size: 12px; color: #888;"></div>
        </div>
    </div>
</div>

<div id="build-menu">
    <div class="build-opt b-top" title="–§—É–Ω–¥–∞–º–µ–Ω—Ç" onclick="setBuildShape('foundation')">‚¨õ</div>
    <div class="build-opt b-left" title="–¢—Ä–∏–∫—É—Ç–Ω–∏–∫" onclick="setBuildShape('triangle')">üî∫</div>
    <div class="build-opt b-right" title="–°—Ç—ñ–Ω–∞" onclick="setBuildShape('wall')">üß±</div>
    <div class="build-opt b-bottom" title="–î–≤–µ—Ä—ñ" onclick="setBuildShape('doorframe')">üö™</div>
    <div class="build-opt b-tr" title="–î–∞—Ö" onclick="setBuildShape('roof')">üè†</div>
    <div class="build-opt b-center" onclick="closeBuildMenu()">‚ùå</div>
</div>

<script>
/**
 * --- CONFIG & DB ---
 */
const cvs = document.getElementById('cvs');
const ctx = cvs.getContext('2d');
const W_MAP = 4000;
const H_MAP = 4000;

// Items
const ITEMS = {
    rock: { name: '–ö–∞–º—ñ–Ω—å', icon: 'ü™®', type: 'tool', dmg: 10, bonus: 'rock' },
    wood: { name: '–î–µ—Ä–µ–≤–æ', icon: 'üå≤', type: 'res' },
    stone: { name: '–†—É–¥–∞', icon: '‚ö™', type: 'res' },
    iron_ore: { name: '–ó–∞–ª—ñ–∑–Ω–∞ —Ä—É–¥–∞', icon: 'üåë', type: 'res' },
    sulfur_ore: { name: '–°—ñ—Ä–∫–∞', icon: 'üü°', type: 'res' },
    metal_frags: { name: '–ó–∞–ª—ñ–∑–æ', icon: 'üî©', type: 'res' },
    hqm: { name: '–ú–í–ö', icon: '‚¨ú', type: 'res' },
    scrap: { name: '–°–∫—Ä–∞–ø', icon: '‚öôÔ∏è', type: 'comp' },
    cloth: { name: '–¢–∫–∞–Ω–∏–Ω–∞', icon: 'üß∂', type: 'comp' },
    fat: { name: '–ñ–∏—Ä', icon: 'ü•©', type: 'comp' },
    leather: { name: '–ö–æ–∂–∞', icon: 'ü•ì', type: 'comp' },
    bone: { name: '–ö—ñ—Å—Ç–∫–∏', icon: 'ü¶¥', type: 'comp' },
    
    // Tools
    axe: { name: '–°–æ–∫–∏—Ä–∞', icon: 'ü™ì', type: 'tool', dmg: 25, bonus: 'tree' },
    pickaxe: { name: '–ö–∏—Ä–∫–∞', icon: '‚õèÔ∏è', type: 'tool', dmg: 25, bonus: 'rock' },
    hammer: { name: '–ö–∏—è–Ω–∫–∞', icon: 'üî®', type: 'tool', dmg: 5, action: 'upgrade' },
    plan: { name: 'Plan', icon: 'üìÑ', type: 'build' },
    
    // Weapons
    bow: { name: '–õ—É–∫', icon: 'üèπ', type: 'weapon', dmg: 30, range: 300 },
    ak: { name: 'AK-47', icon: 'üî´', type: 'weapon', dmg: 15, range: 500, auto: true },
    
    // Deploy
    box: { name: '–Ø—â–∏–∫', icon: 'üì¶', type: 'deploy', w: 40, h: 40, hp: 100 },
    furnace: { name: '–ü—ñ—á', icon: 'üî•', type: 'deploy', w: 40, h: 40, hp: 200, isFurnace: true },
    wb1: { name: '–í–µ—Ä—Å—Ç–∞–∫ 1', icon: 'üõ†Ô∏è', type: 'deploy', w: 60, h: 60, hp: 300, wb: 1 },
    wb2: { name: '–í–µ—Ä—Å—Ç–∞–∫ 2', icon: 'üóúÔ∏è', type: 'deploy', w: 60, h: 60, hp: 500, wb: 2 },
    wb3: { name: '–í–µ—Ä—Å—Ç–∞–∫ 3', icon: 'ü¶æ', type: 'deploy', w: 60, h: 60, hp: 1000, wb: 3 },
    
    // Build parts (Virtual items)
    door_wood: { name: '–î–≤–µ—Ä—ñ (–î–µ—Ä)', icon: 'üö™', type: 'deploy_door', hp: 200 },
    door_metal: { name: '–î–≤–µ—Ä—ñ (–ó–∞–ª)', icon: 'üö™', type: 'deploy_door', hp: 500 },
    
    food: { name: '–á–∂–∞', icon: 'ü•´', type: 'food', val: 30 }
};

// Crafting Recipes
const RECIPES = [
    // Resources / Basics
    { id: 'axe', cat: 'tool', cost: { wood: 100, stone: 50 } },
    { id: 'pickaxe', cat: 'tool', cost: { wood: 100, stone: 50 } },
    { id: 'hammer', cat: 'tool', cost: { wood: 100 } },
    { id: 'plan', cat: 'tool', cost: { wood: 20 } },
    { id: 'metal_frags', cat: 'res', name: '–ü–µ—Ä–µ–ø–ª–∞–≤–∫–∞ (–ü—ñ—á)', cost: { iron_ore: 1, wood: 5 }, reqStation: 'furnace', out: 1 },
    
    // Stations
    { id: 'furnace', cat: 'build', cost: { stone: 200, wood: 100, fat: 30 } },
    { id: 'wb1', cat: 'build', cost: { wood: 500, scrap: 50 } },
    { id: 'wb2', cat: 'build', cost: { wood: 500, metal_frags: 100, scrap: 250 }, wb: 1 },
    { id: 'wb3', cat: 'build', cost: { metal_frags: 1000, hqm: 50, scrap: 1250 }, wb: 2 },
    
    // Construction
    { id: 'door_wood', cat: 'build', cost: { wood: 300 } },
    { id: 'door_metal', cat: 'build', cost: { metal_frags: 150, wood: 50 }, wb: 1 },
    { id: 'box', cat: 'build', cost: { wood: 100 } },
    
    // Weapon / Attire
    { id: 'bow', cat: 'weapon', cost: { wood: 200, cloth: 50 } },
    { id: 'ak', cat: 'weapon', cost: { metal_frags: 400, wood: 200, scrap: 100 }, wb: 2 } // Simplified
];

const CATEGORIES = { tool: '–Ü–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏', build: '–ë—É–¥—ñ–≤–Ω–∏—Ü—Ç–≤–æ', weapon: '–ó–±—Ä–æ—è', res: '–†–µ—Å—É—Ä—Å–∏' };

// Global State
let player = { x: 1000, y: 1000, hp: 100, food: 100, angle: 0, inv: [], belt: [], beltIdx: 0 };
let world = { entities: [], static: [], roofs: [], roadPath: [] };
let cam = { x:0, y:0 };
let input = { w:0, a:0, s:0, d:0, mx:0, my:0 };
let gameLoopId;
let isMenuOpen = false;
let buildShape = 'foundation'; // foundation, wall, etc.

/**
 * --- CORE SYSTEMS ---
 */
function initGame(newGame) {
    document.getElementById('start-screen').style.display = 'none';
    resize();
    
    if(!newGame && localStorage.getItem('rust2d_save')) {
        loadGame();
    } else {
        generateWorld();
        // Starter Kit
        player.belt = Array(6).fill(null);
        player.inv = Array(24).fill(null);
        addItem('rock', 1);
        addItem('food', 3);
    }
    
    startGameLoop();
    setInterval(saveGame, 30000); // Autosave 30s
}

function generateWorld() {
    world.entities = [];
    world.static = [];
    world.roofs = [];
    world.roadPath = [];

    // 1. Generate Curved Road (Sine Wave + Noise approach)
    let roadX = 2000;
    for(let y=0; y<H_MAP; y+=20) {
        roadX += Math.sin(y * 0.002) * 5 + (Math.random()-0.5)*2; 
        // Clamp road to map
        if(roadX < 200) roadX = 200; if(roadX > W_MAP-200) roadX = W_MAP-200;
        world.roadPath.push({x: roadX, y: y});
    }

    // 2. Resources (No Overlap)
    let resources = 0;
    while(resources < 600) {
        let x = Math.random() * W_MAP;
        let y = Math.random() * H_MAP;
        
        // Check Road Dist
        let nearRoad = false;
        for(let i=0; i<world.roadPath.length; i+=10) {
            if(Math.hypot(x - world.roadPath[i].x, y - world.roadPath[i].y) < 80) nearRoad = true;
        }
        if(nearRoad) continue;

        // Check Overlap
        let safe = true;
        for(let e of world.entities) {
            if(Math.hypot(x - e.x, y - e.y) < 50) safe = false;
        }
        if(!safe) continue;

        let rnd = Math.random();
        let type = 'tree';
        if(rnd > 0.6) type = 'stone';
        if(rnd > 0.85) type = 'iron';
        if(rnd > 0.95) type = 'sulfur';

        let hp = (type==='tree')?30:50;
        world.entities.push({ x, y, type, hp, id: Math.random() });
        resources++;
    }

    // 3. Barrels along the road
    for(let i=0; i<world.roadPath.length; i+=15) { // every ~300px
        if(Math.random() < 0.05) {
            let p = world.roadPath[i];
            world.entities.push({ 
                x: p.x + (Math.random()-0.5)*50, 
                y: p.y, 
                type: 'barrel', hp: 10, variant: Math.random()>0.5?'blue':'yellow'
            });
        }
    }

    // 4. Animals
    for(let i=0; i<30; i++) {
        world.entities.push({
            x: Math.random()*W_MAP, y: Math.random()*H_MAP,
            type: 'deer', hp: 50, angle: Math.random()*6.28
        });
    }

    // 5. Monuments (RT)
    createMonument(500, 500, 'Supermarket');
    createMonument(world.roadPath[Math.floor(world.roadPath.length/2)].x + 200, 2000, 'Gas Station');
    
    // Spawn player
    player.x = 200; player.y = H_MAP/2;
}

function createMonument(x, y, type) {
    // Defines a simple room structure
    let w = 400, h = 300;
    // Floor
    world.static.push({x, y, w, h, type: 'floor', mat: 'concrete'});
    
    // Walls (Outer box with openings)
    createWallRect(x, y, w, h, 20, 100); // 100px opening

    // Loot inside
    world.entities.push({x: x+50, y: y+50, type: 'barrel', hp:10, variant:'blue'});
    world.entities.push({x: x+w-50, y: y+h-50, type: 'crate', hp:20});
    world.entities.push({x: x+w/2, y: y+h/2, type: 'crate', hp:20});

    // Roof (Zone)
    world.roofs.push({x, y, w, h, type});
}

function createWallRect(x, y, w, h, thick, doorW) {
    // Top
    world.static.push({x, y, w, h: thick, type: 'wall', hp:9999});
    // Bottom (Split for door)
    let seg = (w-doorW)/2;
    world.static.push({x, y: y+h-thick, w: seg, h: thick, type: 'wall', hp:9999});
    world.static.push({x: x+seg+doorW, y: y+h-thick, w: seg, h: thick, type: 'wall', hp:9999});
    // Sides
    world.static.push({x, y, w: thick, h, type: 'wall', hp:9999});
    world.static.push({x: x+w-thick, y, w: thick, h, type: 'wall', hp:9999});
}

function startGameLoop() {
    if(gameLoopId) cancelAnimationFrame(gameLoopId);
    loop();
}

function loop() {
    update();
    draw();
    gameLoopId = requestAnimationFrame(loop);
}

/**
 * --- LOGIC ---
 */
function update() {
    // Movement
    if(!isMenuOpen) {
        let dx = (input.d - input.a) * 5;
        let dy = (input.s - input.w) * 5;
        if(dx||dy) {
            let nx = player.x + dx;
            let ny = player.y + dy;
            if(!checkCol(nx, player.y)) player.x = nx;
            if(!checkCol(player.x, ny)) player.y = ny;
            
            // Map bounds
            player.x = Math.max(0, Math.min(W_MAP, player.x));
            player.y = Math.max(0, Math.min(H_MAP, player.y));
        }
        player.angle = Math.atan2(input.my - cvs.height/2, input.mx - cvs.width/2);
    }
    
    // Camera follow
    cam.x = player.x - cvs.width/2;
    cam.y = player.y - cvs.height/2;

    // Animal AI (Passive wandering)
    world.entities.forEach(e => {
        if(e.type === 'deer') {
            if(Math.random() < 0.02) e.angle += (Math.random()-0.5);
            if(Math.random() < 0.6) {
                let speed = 1;
                e.x += Math.cos(e.angle)*speed;
                e.y += Math.sin(e.angle)*speed;
            }
        }
    });

    // Hunger
    if(Math.random() < 0.005) {
        player.food -= 0.1;
        if(player.food <= 0) player.hp -= 0.1;
        updateUI();
    }
}

function checkCol(x, y) {
    let r = 15;
    // Check static walls (Foundations are walkable!)
    for(let b of world.static) {
        if(b.type === 'wall' || b.type === 'door_locked') {
            if(x+r > b.x && x-r < b.x+b.w && y+r > b.y && y-r < b.y+b.h) return true;
        }
    }
    // Check deployables (Furnace, Workbench, High Walls)
    for(let e of world.entities) {
        if(e.type.startsWith('wb') || e.type === 'furnace' || e.type === 'wall') {
            // Simplified box collision for entities
            let size = 40;
            if(x > e.x-size && x < e.x+size && y > e.y-size && y < e.y+size) return true;
        }
    }
    return false;
}

/**
 * --- INTERACTION ---
 */
window.onmousedown = (e) => {
    if(isMenuOpen) return;
    
    let hand = player.belt[player.beltIdx];
    
    // Right Click
    if(e.button === 2) {
        if(hand && hand.id === 'plan') {
            // Open Radial
            let m = document.getElementById('build-menu');
            m.style.display = 'block';
            m.style.left = (input.mx - 100) + 'px';
            m.style.top = (input.my - 100) + 'px';
            return;
        }
    }
    
    // Left Click
    if(e.button === 0) {
        if(hand && hand.id === 'plan') doBuild();
        else if(hand && hand.id === 'hammer') doHammer();
        else doAttack();
    }
};

function doAttack() {
    let wx = cam.x + input.mx;
    let wy = cam.y + input.my;
    let hand = player.belt[player.beltIdx];
    let range = (hand && ITEMS[hand.id].range) || 100;
    
    // Hit Entities
    for(let i=0; i<world.entities.length; i++) {
        let e = world.entities[i];
        if(Math.hypot(e.x - wx, e.y - wy) < 30 && Math.hypot(player.x - e.x, player.y - e.y) < range) {
            let dmg = (hand && ITEMS[hand.id].dmg) || 5;
            let bonus = (hand && ITEMS[hand.id].bonus);
            
            // Gather bonus
            if(bonus === 'tree' && e.type === 'tree') dmg *= 2;
            if(bonus === 'rock' && (e.type === 'stone' || e.type === 'iron' || e.type === 'sulfur')) dmg *= 2;

            e.hp -= dmg;
            e.shake = 5;
            
            // Give resources
            if(e.hp <= 0) {
                giveLoot(e);
                world.entities.splice(i, 1);
            }
            return;
        }
    }
}

function giveLoot(e) {
    if(e.type === 'tree') { addItem('wood', 50); notify("+Wood"); }
    else if(e.type === 'stone') { addItem('stone', 30); notify("+Stone"); }
    else if(e.type === 'iron') { addItem('iron_ore', 20); if(Math.random()>0.8) addItem('hqm', 1); notify("+Iron Ore"); }
    else if(e.type === 'sulfur') { addItem('sulfur_ore', 20); notify("+Sulfur"); }
    else if(e.type === 'barrel') { addItem('scrap', 2); addItem('comp', 1); notify("+Scrap"); }
    else if(e.type === 'crate') { addItem('scrap', 10); addItem('metal_frags', 5); notify("Looted!"); }
    else if(e.type === 'deer') { addItem('leather', 5); addItem('bone', 10); addItem('fat', 5); addItem('food', 2); notify("Hunted!"); }
}

function doBuild() {
    let wx = cam.x + input.mx;
    let wy = cam.y + input.my;
    
    // Grid snap
    let bx = Math.floor(wx/50)*50;
    let by = Math.floor(wy/50)*50;

    let cost = 0;
    let type = 'wall';
    let isFloor = false;

    if(buildShape === 'foundation') { cost = 50; type = 'floor'; isFloor = true; }
    else if(buildShape === 'triangle') { cost = 25; type = 'floor_tri'; isFloor = true; }
    else if(buildShape === 'wall') { cost = 50; type = 'wall'; }
    else if(buildShape === 'doorframe') { cost = 40; type = 'doorframe'; }
    else if(buildShape === 'roof') { cost = 30; type = 'roof_build'; }

    if(countItem('wood') >= cost) {
        takeItem('wood', cost);
        world.static.push({
            x: bx, y: by, w: 50, h: 50, 
            type: type, 
            mat: 'wood', // Material level
            hp: 200,
            maxHp: 200
        });
        notify(`Built ${buildShape}`);
    } else {
        notify("Need Wood!");
    }
}

function doHammer() {
    let wx = cam.x + input.mx;
    let wy = cam.y + input.my;
    
    // Find static obj
    for(let b of world.static) {
        if(b.x < wx && b.x+b.w > wx && b.y < wy && b.y+b.h > wy) {
            // Upgrade Logic
            if(b.mat === 'wood' && countItem('stone') >= 50) {
                takeItem('stone', 50);
                b.mat = 'stone';
                b.hp = 500; b.maxHp = 500;
                notify("Upgraded to Stone");
            } else if(b.mat === 'stone' && countItem('metal_frags') >= 50) {
                takeItem('metal_frags', 50);
                b.mat = 'sheet';
                b.hp = 1000; b.maxHp = 1000;
                notify("Upgraded to Sheet Metal");
            } else {
                notify("Cannot upgrade / No resources");
            }
            return;
        }
    }
}

function setBuildShape(s) {
    buildShape = s;
    closeBuildMenu();
    notify("Selected: " + s);
}
function closeBuildMenu() {
    document.getElementById('build-menu').style.display = 'none';
}

/**
 * --- RENDER ---
 */
function draw() {
    // Clear
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#111'; ctx.fillRect(0,0,cvs.width, cvs.height);
    
    // Cam transform
    ctx.translate(-cam.x, -cam.y);

    // 1. Terrain
    // Optimization: Only draw visible area logic would go here, but for simplicity we draw big rects
    // Water
    ctx.fillStyle = '#1565c0'; ctx.fillRect(cam.x, cam.y, cvs.width, cvs.height);
    // Grass Map
    ctx.fillStyle = '#33691e'; ctx.fillRect(0, 0, W_MAP, H_MAP);
    
    // 2. Road
    ctx.beginPath();
    ctx.moveTo(world.roadPath[0].x, world.roadPath[0].y);
    for(let p of world.roadPath) ctx.lineTo(p.x, p.y);
    ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 60; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.stroke();
    // Road center line
    ctx.strokeStyle = '#8d6e63'; ctx.lineWidth = 2; ctx.setLineDash([20, 20]); ctx.stroke();
    ctx.setLineDash([]);

    // 3. Static Objects (Floors first)
    // Draw floors
    world.static.forEach(b => {
        if(b.type.includes('floor')) drawBuild(b);
    });

    // 4. Entities & Walls (Sorted by Y for depth)
    let renderList = [];
    world.entities.forEach(e => renderList.push({y:e.y, draw: ()=>drawEntity(e)}));
    world.static.forEach(b => {
        if(!b.type.includes('floor')) renderList.push({y:b.y+b.h, draw: ()=>drawBuild(b)});
    });
    // Player
    renderList.push({y:player.y, draw: ()=>drawPlayer()});

    renderList.sort((a,b)=>a.y - b.y);
    renderList.forEach(r => r.draw());

    // 5. Roofs (Monuments)
    world.roofs.forEach(r => {
        // Fade out if player inside
        let dist = Math.hypot(player.x - (r.x+r.w/2), player.y - (r.y+r.h/2));
        if(dist > Math.max(r.w, r.h)/1.5) {
            ctx.fillStyle = '#212121';
            ctx.fillRect(r.x, r.y, r.w, r.h);
            ctx.fillStyle = '#fff';
            ctx.font = '30px sans-serif'; ctx.textAlign='center';
            ctx.fillText(r.type, r.x+r.w/2, r.y+r.h/2);
        }
    });
}

function drawEntity(e) {
    if(e.shake) { ctx.save(); ctx.translate(Math.random()*2, Math.random()*2); e.shake--; }
    
    if(e.type === 'tree') {
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.arc(e.x+5, e.y+5, 15, 0, 6.28); ctx.fill();
        ctx.fillStyle = '#5d4037'; ctx.beginPath(); ctx.arc(e.x, e.y, 10, 0, 6.28); ctx.fill();
        ctx.fillStyle = '#2e7d32'; ctx.beginPath(); ctx.arc(e.x, e.y, 30, 0, 6.28); ctx.fill();
    } 
    else if(e.type.includes('stone') || e.type.includes('iron') || e.type.includes('sulfur')) {
        let color = '#9e9e9e';
        if(e.type === 'iron') color = '#5d4037'; // brown-ish
        if(e.type === 'sulfur') color = '#ffeb3b';
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.moveTo(e.x, e.y-20); ctx.lineTo(e.x+20, e.y+10); ctx.lineTo(e.x-20, e.y+10); ctx.fill();
        if(e.type === 'iron') { ctx.fillStyle='#d7ccc8'; ctx.beginPath(); ctx.arc(e.x, e.y-5, 5, 0, 6.28); ctx.fill(); }
    }
    else if(e.type === 'barrel') {
        ctx.fillStyle = (e.variant==='blue') ? '#1565c0' : '#fbc02d';
        ctx.beginPath(); ctx.arc(e.x, e.y, 15, 0, 6.28); ctx.fill();
        ctx.strokeStyle = '#5d4037'; ctx.lineWidth=2; ctx.stroke(); // Rust outline
    }
    else if(e.type === 'deer') {
        ctx.fillStyle = '#8d6e63';
        ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle);
        ctx.fillRect(-10, -5, 20, 10);
        ctx.beginPath(); ctx.arc(10, 0, 5, 0, 6.28); ctx.fill(); // head
        ctx.restore();
    }
    else if(e.type === 'crate') {
        ctx.fillStyle = '#6d4c41'; ctx.fillRect(e.x-15, e.y-15, 30, 30);
        ctx.strokeStyle = '#a1887f'; ctx.strokeRect(e.x-15, e.y-15, 30, 30);
    }
    else if(e.type === 'furnace') {
        ctx.fillStyle = '#757575'; ctx.beginPath(); ctx.arc(e.x, e.y, 20, 0, 6.28); ctx.fill();
        ctx.fillStyle = '#ff5722'; ctx.beginPath(); ctx.arc(e.x, e.y, 10, 0, 6.28); ctx.fill(); // Fire
    }
    
    if(e.shake) ctx.restore();
}

function drawBuild(b) {
    let colors = { wood: '#8d6e63', stone: '#9e9e9e', sheet: '#37474f', concrete: '#424242' };
    ctx.fillStyle = colors[b.mat] || '#555';
    ctx.strokeStyle = '#222'; ctx.lineWidth = 2;
    
    if(b.type === 'floor_tri') {
        ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(b.x+b.w, b.y); ctx.lineTo(b.x, b.y+b.h); ctx.fill(); ctx.stroke();
    } else {
        ctx.fillRect(b.x, b.y, b.w, b.h);
        ctx.strokeRect(b.x, b.y, b.w, b.h);
    }
}

function drawPlayer() {
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle);
    // Body
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0,0,14,0,6.28); ctx.fill();
    // Hands
    ctx.fillStyle = '#fbc02d';
    ctx.beginPath(); ctx.arc(10, 10, 5, 0, 6.28); ctx.fill();
    ctx.beginPath(); ctx.arc(10, -10, 5, 0, 6.28); ctx.fill();
    // Item
    let hand = player.belt[player.beltIdx];
    if(hand) {
        ctx.fillStyle = '#ccc';
        if(ITEMS[hand.id].type === 'weapon') { ctx.fillStyle = '#000'; ctx.fillRect(10, -3, 30, 6); }
        else if(ITEMS[hand.id].id === 'plan') { ctx.fillStyle = 'blue'; ctx.fillRect(5, -5, 10, 10); }
    }
    ctx.restore();
}

/**
 * --- INVENTORY SYSTEM ---
 */
function addItem(id, count) {
    // Try Belt
    for(let i=0; i<6; i++) {
        if(player.belt[i] && player.belt[i].id === id) { player.belt[i].count += count; updateUI(); return; }
        if(!player.belt[i] && !hasItemInInv(id)) { player.belt[i] = {id, count}; updateUI(); return; } // Pref belt if not in inv
    }
    // Try Inv
    for(let i=0; i<player.inv.length; i++) {
        if(player.inv[i] && player.inv[i].id === id) { player.inv[i].count += count; updateUI(); return; }
    }
    for(let i=0; i<player.inv.length; i++) {
        if(!player.inv[i]) { player.inv[i] = {id, count}; updateUI(); return; }
    }
}
function hasItemInInv(id) { return player.inv.some(s=>s&&s.id===id) || player.belt.some(s=>s&&s.id===id); }
function countItem(id) {
    let c = 0;
    [...player.belt, ...player.inv].forEach(s => { if(s && s.id===id) c += s.count });
    return c;
}
function takeItem(id, n) {
    let left = n;
    [player.belt, player.inv].forEach(list => {
        list.forEach((s, i) => {
            if(left > 0 && s && s.id === id) {
                let take = Math.min(s.count, left);
                s.count -= take; left -= take;
                if(s.count <= 0) list[i] = null;
            }
        });
    });
    updateUI();
}

/**
 * --- UI & CRAFTING ---
 */
function updateUI() {
    document.getElementById('hp-bar').style.width = player.hp + '%';
    document.getElementById('food-bar').style.width = player.food + '%';

    // Hotbar
    let hb = document.getElementById('hotbar'); hb.innerHTML = '';
    player.belt.forEach((s, i) => {
        let d = document.createElement('div');
        d.className = 'slot ' + (i===player.beltIdx?'active':'');
        if(s) d.innerHTML = `<div class="slot-icon">${ITEMS[s.id].icon}</div><div class="slot-count">${s.count}</div>`;
        d.onclick = () => { player.beltIdx = i; updateUI(); };
        hb.appendChild(d);
    });

    // Main Inv
    let gr = document.getElementById('inv-grid'); gr.innerHTML = '';
    player.inv.forEach((s, i) => {
        let d = document.createElement('div'); d.className = 'slot';
        if(s) d.innerHTML = `<div class="slot-icon">${ITEMS[s.id].icon}</div><div class="slot-count">${s.count}</div>`;
        // Simple move to belt logic for demo
        d.onclick = () => { if(s && !player.belt[player.beltIdx]) { player.belt[player.beltIdx] = s; player.inv[i] = null; updateUI(); } };
        gr.appendChild(d);
    });
}

function renderCraftTabs() {
    let t = document.getElementById('craft-tabs'); t.innerHTML = '';
    for(let k in CATEGORIES) {
        let b = document.createElement('div'); b.className = 'tab'; b.innerText = CATEGORIES[k];
        b.onclick = () => renderCraftList(k);
        t.appendChild(b);
    }
    renderCraftList('tool'); // Default
}

function renderCraftList(cat) {
    let l = document.getElementById('craft-list'); l.innerHTML = '';
    
    // Check WB level nearby
    let nearWb = 0;
    let nearFurnace = false;
    world.entities.forEach(e => {
        if(Math.hypot(player.x-e.x, player.y-e.y) < 150) {
            if(e.type === 'wb1') nearWb = Math.max(nearWb, 1);
            if(e.type === 'wb2') nearWb = Math.max(nearWb, 2);
            if(e.type === 'wb3') nearWb = Math.max(nearWb, 3);
            if(e.type === 'furnace') nearFurnace = true;
        }
    });

    RECIPES.forEach(r => {
        if(r.cat !== cat) return;
        
        let el = document.createElement('div'); el.className = 'craft-row';
        let item = ITEMS[r.id];
        
        // Requirements String
        let reqs = Object.keys(r.cost).map(k => `${ITEMS[k].icon}${r.cost[k]}`).join(' ');
        let wbReq = r.wb ? ` | WB Lev ${r.wb}` : '';
        let stReq = r.reqStation === 'furnace' ? ' | Need üî•' : '';
        
        el.innerHTML = `
            <div style="display:flex; align-items:center; gap:10px;">
                <span style="font-size:20px">${item.icon}</span>
                <div>
                    <div>${item.name}</div>
                    <div style="font-size:10px; color:#aaa">${reqs} ${wbReq} ${stReq}</div>
                </div>
            </div>
            <button style="padding:5px 10px; background:#76ff03; border:none; color:black; font-weight:bold; cursor:pointer">Craft</button>
        `;

        // Validation
        let canCraft = true;
        for(let k in r.cost) if(countItem(k) < r.cost[k]) canCraft = false;
        if(r.wb && nearWb < r.wb) canCraft = false;
        if(r.reqStation === 'furnace' && !nearFurnace) canCraft = false;

        if(!canCraft) { el.classList.add('locked'); el.onclick = null; }
        else {
            el.onclick = () => {
                for(let k in r.cost) takeItem(k, r.cost[k]);
                addItem(r.id, r.out || 1);
                notify("Crafted " + item.name);
                renderCraftList(cat); // Update UI
            }
        }
        l.appendChild(el);
    });
}

function notify(msg) {
    let d = document.createElement('div'); d.className = 'note'; d.innerText = msg;
    document.getElementById('notify-area').appendChild(d);
    setTimeout(()=>d.remove(), 4000);
}

/**
 * --- SAVE SYSTEM ---
 */
function saveGame() {
    if(player.hp <= 0) return; // Don't save dead state
    let data = { player, world };
    localStorage.setItem('rust2d_save', JSON.stringify(data));
    notify("Game Saved");
}

function loadGame() {
    try {
        let d = JSON.parse(localStorage.getItem('rust2d_save'));
        player = d.player;
        world = d.world;
        notify("Save Loaded!");
    } catch(e) {
        console.error("Save Load Error", e);
        generateWorld();
    }
}

/**
 * --- INPUTS ---
 */
window.onkeydown = e => {
    if(e.code === 'KeyW') input.w = 1;
    if(e.code === 'KeyS') input.s = 1;
    if(e.code === 'KeyA') input.a = 1;
    if(e.code === 'KeyD') input.d = 1;
    if(e.key >= '1' && e.key <= '6') { player.beltIdx = parseInt(e.key)-1; updateUI(); }
    
    if(e.code === 'KeyE') {
        isMenuOpen = !isMenuOpen;
        document.getElementById('game-menu').style.display = isMenuOpen ? 'flex' : 'none';
        if(isMenuOpen) renderCraftTabs();
    }
    // Context Menu disable default
    if(e.code === 'Escape') { closeBuildMenu(); isMenuOpen=false; document.getElementById('game-menu').style.display='none'; }
};
window.onkeyup = e => {
    if(e.code === 'KeyW') input.w = 0;
    if(e.code === 'KeyS') input.s = 0;
    if(e.code === 'KeyA') input.a = 0;
    if(e.code === 'KeyD') input.d = 0;
};
window.onmousemove = e => { input.mx = e.clientX; input.my = e.clientY; };
window.oncontextmenu = e => e.preventDefault();
window.onresize = resize;

function resize() { cvs.width = window.innerWidth; cvs.height = window.innerHeight; }

</script>
</body>
</html>
