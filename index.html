<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>Rust 2D: Ultimate Fix</title>
<style>
    body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', sans-serif; user-select: none; }
    canvas { display: block; }

    /* UI Layers */
    #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    .pointer { pointer-events: auto; }

    /* HUD */
    #hud { position: absolute; bottom: 20px; left: 20px; display: flex; flex-direction: column; gap: 8px; }
    .bar { width: 250px; height: 25px; background: rgba(0,0,0,0.8); border: 2px solid #333; border-radius: 4px; overflow: hidden; position: relative; }
    .fill { height: 100%; transition: width 0.2s; }
    .bar-text { position: absolute; right: 10px; top: 0; font-size: 14px; color: white; font-weight: bold; line-height: 25px; text-shadow: 1px 1px 2px #000; }

    /* HOTBAR (BIGGER) */
    #hotbar { 
        position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); 
        display: flex; gap: 10px; padding: 10px; 
        background: rgba(0,0,0,0.5); border-radius: 12px; border: 1px solid #444; 
    }
    .slot { 
        width: 75px; height: 75px; /* –ë–û–õ–¨–®–û–ô –†–ê–ó–ú–ï–† */
        background: rgba(40,40,40,0.95); border: 2px solid #555; 
        color: white; display: flex; flex-direction: column; align-items: center; justify-content: center;
        font-size: 12px; cursor: pointer; position: relative; border-radius: 6px;
        transition: transform 0.1s;
    }
    .slot:hover { background: #555; border-color: #999; }
    .slot.active { border-color: #76ff03; box-shadow: 0 0 20px rgba(118, 255, 3, 0.4); transform: translateY(-5px); }
    .slot-icon { font-size: 40px; filter: drop-shadow(0 4px 2px rgba(0,0,0,0.6)); }
    .slot-count { position: absolute; bottom: 4px; right: 6px; font-weight: bold; font-size: 16px; color: #fff; text-shadow: 2px 2px 0 #000; }

    /* NOTIFICATIONS (BOTTOM RIGHT) */
    #notify-area { 
        position: absolute; bottom: 150px; right: 20px; 
        display: flex; flex-direction: column; gap: 5px; align-items: flex-end; 
    }
    .note { 
        background: rgba(30,30,30,0.95); color: #fff; padding: 10px 20px; 
        border-right: 5px solid #76ff03; font-size: 18px; font-weight: bold;
        animation: fadeOut 3s forwards; box-shadow: 0 4px 10px black; 
    }
    @keyframes fadeOut { 0% {opacity:1; transform: translateX(0);} 80% {opacity:1;} 100% {opacity:0; transform: translateX(50px);} }

    /* MENUS */
    .menu-overlay { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); 
        display: none; justify-content: center; align-items: center; z-index: 50; pointer-events: auto;
    }
    .panel { 
        background: #282828; border: 1px solid #444; padding: 30px; color: #eee; border-radius: 8px; 
        box-shadow: 0 20px 50px rgba(0,0,0,1); display: flex; gap: 30px; 
    }
    .inv-container { display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px; }
    
    /* DRAG GHOST */
    #drag-ghost {
        position: fixed; width: 75px; height: 75px; pointer-events: none; z-index: 999;
        display: none; opacity: 0.9; transform: translate(-50%, -50%);
    }
    #drag-ghost .slot { border-color: #76ff03; background: #333; box-shadow: 0 10px 20px rgba(0,0,0,0.5); }
    
    /* Crafting Styles */
    .craft-list { height: 400px; overflow-y: auto; width: 300px; }
    .craft-row { display: flex; justify-content: space-between; padding: 10px; background: #333; margin-bottom: 5px; cursor: pointer; border: 1px solid #444; }
    .craft-row:hover { background: #444; border-color: #888; }
</style>
</head>
<body>

<canvas id="cvs"></canvas>
<div id="drag-ghost"></div>

<div id="ui-layer">
    <div id="notify-area"></div>
    
    <div id="hud">
        <div class="bar"><div class="fill" id="hp-bar" style="background:#e53935; width:100%"></div><span class="bar-text">HP</span></div>
        <div class="bar"><div class="fill" id="food-bar" style="background:#fb8c00; width:100%"></div><span class="bar-text">FOOD</span></div>
    </div>
    
    <div id="hotbar" class="pointer"></div>
</div>

<div id="game-menu" class="menu-overlay">
    <div class="panel">
        <div>
            <h3>–†–Æ–ö–ó–ê–ö</h3>
            <div class="inv-container" id="inv-grid"></div>
        </div>
        <div style="border-left: 1px solid #555; padding-left: 20px;">
            <h3>–ö–†–ê–§–¢</h3>
            <div class="craft-list" id="craft-list"></div>
        </div>
    </div>
</div>

<script>
/** * CONSTANTS 
 */
const cvs = document.getElementById('cvs');
const ctx = cvs.getContext('2d');
const W_MAP = 4000;
const H_MAP = 4000;
const X_WATER = 300; // –ü–ª—è–∂ —Å–ª–µ–≤–∞

// ITEM DATABASE
const ITEMS = {
    rock: { name: '–ö–∞–º—ñ–Ω—å', icon: 'ü™®', type: 'tool', dmg: 10, bonus: 'rock' },
    wood: { name: '–î–µ—Ä–µ–≤–æ', icon: 'üå≤', type: 'res' },
    stone: { name: '–†—É–¥–∞', icon: 'üåë', type: 'res' }, 
    iron_ore: { name: '–ó–∞–ª—ñ–∑–Ω–∞ —Ä—É–¥–∞', icon: 'ü™®', type: 'res' },
    sulfur_ore: { name: '–°—ñ—Ä–∫–∞', icon: 'üü°', type: 'res' },
    metal_frags: { name: '–ó–∞–ª—ñ–∑–æ', icon: 'üî©', type: 'res' },
    scrap: { name: '–°–∫—Ä–∞–ø', icon: '‚öôÔ∏è', type: 'comp' },
    cloth: { name: '–¢–∫–∞–Ω–∏–Ω–∞', icon: 'üß∂', type: 'comp' },
    fat: { name: '–ñ–∏—Ä', icon: 'ü•©', type: 'comp' },
    comp: { name: '–ö–æ–º–ø–æ–Ω–µ–Ω—Ç–∏', icon: 'üîå', type: 'comp' },
    
    axe: { name: '–°–æ–∫–∏—Ä–∞', icon: 'ü™ì', type: 'tool', dmg: 30, bonus: 'tree' },
    pickaxe: { name: '–ö–∏—Ä–∫–∞', icon: '‚õèÔ∏è', type: 'tool', dmg: 30, bonus: 'rock' },
    hammer: { name: '–ö–∏—è–Ω–∫–∞', icon: 'üî®', type: 'tool', dmg: 5 },
    plan: { name: 'Plan', icon: 'üìÑ', type: 'build' },
    
    bow: { name: '–õ—É–∫', icon: 'üèπ', type: 'weapon', dmg: 40 },
    ak: { name: 'AK-47', icon: 'üî´', type: 'weapon', dmg: 15, auto: true },
    
    box: { name: '–Ø—â–∏–∫', icon: 'üì¶', type: 'deploy' },
    furnace: { name: '–ü—ñ—á', icon: 'üî•', type: 'deploy' },
    
    food: { name: '–á–∂–∞', icon: 'ü•´', type: 'food', val: 30 }
};

const RECIPES = [
    { id: 'axe', cost: { wood: 100, stone: 50 } },
    { id: 'pickaxe', cost: { wood: 100, stone: 50 } },
    { id: 'hammer', cost: { wood: 100 } },
    { id: 'plan', cost: { wood: 20 } },
    { id: 'bow', cost: { wood: 200, cloth: 50 } },
    { id: 'furnace', cost: { stone: 200, wood: 100, fat: 20 } },
    { id: 'box', cost: { wood: 100 } },
    { id: 'metal_frags', cost: { iron_ore: 1, wood: 5 }, out: 1 }
];

// STATE
let player = { x: 600, y: 2000, hp: 100, food: 100, angle: 0, inv: Array(24).fill(null), belt: Array(6).fill(null), beltIdx: 0 };
let world = { entities: [], static: [], roofs: [], roadPath: [] };
let cam = { x:0, y:0 };
let input = { w:0, a:0, s:0, d:0, mx:0, my:0 };
let dragObj = { active: false, item: null, fromIdx: -1, fromType: null };
let gameTime = 0;

/**
 * GENERATION (ROADS & MONUMENTS RESTORED)
 */
function initGame() {
    resize();
    generateWorld();
    
    // Starter Items
    if(!player.belt[0]) addItem('rock', 1);
    
    updateUI();
    loop();
}

function generateWorld() {
    world.entities = [];
    world.static = [];
    world.roofs = [];
    world.roadPath = [];

    // 1. ROAD GENERATION (Sine Wave)
    let rx = 1500;
    for(let y=0; y<H_MAP; y+=20) {
        rx += Math.sin(y*0.003) * 5 + (Math.random()-0.5)*2;
        if(rx < 600) rx = 600; if(rx > W_MAP-600) rx = W_MAP-600;
        world.roadPath.push({x: rx, y: y});
    }

    // 2. MONUMENTS (RT)
    createMonument(world.roadPath[20].x - 300, 400, "Supermarket");
    createMonument(world.roadPath[150].x + 200, 3000, "Gas Station");

    // 3. BARRELS (Strictly on Road)
    for(let i=0; i<world.roadPath.length; i+=10) { // Every ~200px
        if(Math.random() < 0.15) { // 15% chance
            let p = world.roadPath[i];
            world.entities.push({
                x: p.x + (Math.random()-0.5)*50, 
                y: p.y + (Math.random()-0.5)*50,
                type: 'barrel', hp: 10
            });
        }
    }

    // 4. NATURE (Trees/Rocks) - Away from road
    for(let i=0; i<500; i++) {
        let x = X_WATER + Math.random()*(W_MAP-X_WATER);
        let y = Math.random()*H_MAP;
        
        // Check distance to road
        let nearRoad = false;
        for(let j=0; j<world.roadPath.length; j+=20) {
            let p = world.roadPath[j];
            if(Math.hypot(x-p.x, y-p.y) < 150) nearRoad = true;
        }
        if(nearRoad) continue;

        let type = Math.random() > 0.7 ? (Math.random()>0.5?'stone':'iron') : 'tree';
        if(Math.random()>0.95) type = 'sulfur';
        
        let hp = type==='tree' ? 30 : 50;
        world.entities.push({x, y, type, hp, id: Math.random(), scale: 0.8+Math.random()*0.5});
    }

    // 5. DEER
    for(let i=0; i<30; i++) {
        world.entities.push({
            x: Math.random()*W_MAP, y: Math.random()*H_MAP,
            type: 'deer', hp: 40, angle: Math.random()*6.28, speed: 0, state: 'idle'
        });
    }
}

function createMonument(x, y, name) {
    let w = 400, h = 300;
    // Floor
    world.static.push({x, y, w, h, type: 'floor'});
    
    // Walls (Outer Box)
    let t = 15;
    world.static.push({x, y, w, h:t, type:'wall'}); // Top
    world.static.push({x, y:y+h-t, w, h:t, type:'wall'}); // Bot
    world.static.push({x, y, w:t, h, type:'wall'}); // Left
    world.static.push({x:x+w-t, y, w:t, h, type:'wall'}); // Right

    // Loot
    world.entities.push({x:x+w/2, y:y+h/2, type:'crate', hp:20});
    world.entities.push({x:x+50, y:y+50, type:'barrel', hp:10});

    // Roof
    world.roofs.push({x, y, w, h, name});
}

function loop() {
    gameTime += 0.05;
    update();
    draw();
    requestAnimationFrame(loop);
}

/**
 * UPDATE LOGIC
 */
function update() {
    let speed = 4;
    let dx = (input.d - input.a) * speed;
    let dy = (input.s - input.w) * speed;
    
    if(dx||dy) {
        let nx = player.x + dx;
        let ny = player.y + dy;
        // Simple bounds
        if(nx > X_WATER && nx < W_MAP) player.x = nx;
        if(ny > 0 && ny < H_MAP) player.y = ny;
    }
    
    player.angle = Math.atan2(input.my - cvs.height/2, input.mx - cvs.width/2);
    cam.x = player.x - cvs.width/2;
    cam.y = player.y - cvs.height/2;

    // AI
    world.entities.forEach(e => {
        if(e.type === 'deer') {
            if(e.speed > 0) {
                e.x += Math.cos(e.angle)*e.speed;
                e.y += Math.sin(e.angle)*e.speed;
                e.speed *= 0.95;
            }
            if(Math.random()<0.01) { e.angle += Math.random()-0.5; e.speed=2; }
        }
    });
}

/**
 * RENDER
 */
function draw() {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#111'; ctx.fillRect(0,0,cvs.width, cvs.height);
    ctx.translate(-cam.x, -cam.y);

    // 1. WATER & LAND
    ctx.fillStyle = '#1565c0'; 
    ctx.beginPath(); ctx.moveTo(cam.x, cam.y);
    for(let y=cam.y; y<cam.y+cvs.height; y+=20) {
        ctx.lineTo(X_WATER + Math.sin(y*0.01+gameTime)*15, y);
    }
    ctx.lineTo(cam.x, cam.y+cvs.height); ctx.fill();
    
    ctx.fillStyle = '#33691e'; ctx.fillRect(X_WATER, 0, W_MAP, H_MAP);

    // 2. ROAD (Thick Gray Line)
    ctx.strokeStyle = '#555'; ctx.lineWidth = 80; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath(); 
    if(world.roadPath.length > 0) {
        ctx.moveTo(world.roadPath[0].x, world.roadPath[0].y);
        for(let p of world.roadPath) ctx.lineTo(p.x, p.y);
        ctx.stroke();
    }
    // Dash line
    ctx.strokeStyle = '#777'; ctx.lineWidth = 2; ctx.setLineDash([20,20]); ctx.stroke(); ctx.setLineDash([]);

    // 3. STATIC (Floors/Walls)
    world.static.forEach(s => {
        ctx.fillStyle = s.type==='floor' ? '#333' : '#111';
        ctx.fillRect(s.x, s.y, s.w, s.h);
        if(s.type==='wall') { ctx.strokeStyle='#555'; ctx.strokeRect(s.x, s.y, s.w, s.h); }
    });

    // 4. ENTITIES (Sorted Y)
    let list = [...world.entities, {type:'player', y:player.y}];
    list.sort((a,b)=>a.y - b.y);

    list.forEach(e => {
        if(e.type==='player') drawPlayer();
        else drawEntity(e);
    });

    // 5. ROOFS (Hide if inside)
    world.roofs.forEach(r => {
        let cx = r.x+r.w/2, cy = r.y+r.h/2;
        let dist = Math.hypot(player.x-cx, player.y-cy);
        if(dist > Math.min(r.w, r.h)/1.5) {
            ctx.fillStyle = '#212121'; ctx.fillRect(r.x, r.y, r.w, r.h);
            ctx.fillStyle = 'white'; ctx.font = '30px sans-serif'; ctx.textAlign='center';
            ctx.fillText(r.name, cx, cy);
        }
    });
}

function drawEntity(e) {
    if(e.shake) { ctx.save(); ctx.translate(Math.random()*2, 0); e.shake--; }
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.ellipse(e.x, e.y+5, 15, 6, 0, 0, 6.28); ctx.fill();

    if(e.type === 'tree') {
        let s = e.scale || 1;
        ctx.fillStyle = '#3e2723'; ctx.fillRect(e.x-5*s, e.y-10*s, 10*s, 20*s);
        ctx.fillStyle = '#1b5e20';
        ctx.beginPath(); ctx.moveTo(e.x-25*s, e.y-5*s); ctx.lineTo(e.x, e.y-50*s); ctx.lineTo(e.x+25*s, e.y-5*s); ctx.fill();
        ctx.beginPath(); ctx.moveTo(e.x-20*s, e.y-25*s); ctx.lineTo(e.x, e.y-65*s); ctx.lineTo(e.x+20*s, e.y-25*s); ctx.fill();
    } 
    else if(e.type.includes('stone') || e.type.includes('iron') || e.type.includes('sulfur')) {
        let c = e.type==='iron'?'#5d4037':(e.type==='sulfur'?'#fdd835':'#9e9e9e');
        ctx.fillStyle = c; 
        ctx.beginPath(); 
        for(let i=0; i<7; i++) {
            let a = i/7 * 6.28;
            let r = 20 + Math.sin(e.id*10 + i)*5;
            ctx.lineTo(e.x + Math.cos(a)*r, e.y - 10 + Math.sin(a)*r);
        }
        ctx.fill();
    }
    else if(e.type === 'barrel') {
        ctx.fillStyle = '#1565c0'; ctx.beginPath(); ctx.arc(e.x, e.y-10, 15, 0, 6.28); ctx.fill();
        ctx.strokeStyle='#000'; ctx.stroke();
    }
    else if(e.type === 'crate') {
        ctx.fillStyle = '#5d4037'; ctx.fillRect(e.x-15, e.y-15, 30, 30);
        ctx.strokeStyle = '#8d6e63'; ctx.strokeRect(e.x-15, e.y-15, 30, 30);
    }
    else if(e.type === 'deer') {
        ctx.fillStyle = '#795548'; ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle);
        ctx.fillRect(-10, -5, 20, 10); ctx.beginPath(); ctx.arc(12, 0, 5, 0, 6.28); ctx.fill();
        ctx.restore();
    }
    if(e.shake) ctx.restore();
}

function drawPlayer() {
    ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.angle);
    ctx.fillStyle = '#ffcc80'; ctx.beginPath(); ctx.arc(0,0,12,0,6.28); ctx.fill();
    ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(0,0,10,0,6.28); ctx.fill();
    ctx.fillStyle = '#ffcc80'; ctx.beginPath(); ctx.arc(12, 10, 5, 0, 6.28); ctx.fill(); ctx.beginPath(); ctx.arc(12, -10, 5, 0, 6.28); ctx.fill();
    
    let h = player.belt[player.beltIdx];
    if(h) {
        ctx.fillStyle = '#888';
        if(h.id=='ak') { ctx.fillStyle='#000'; ctx.fillRect(10, -3, 35, 6); }
        else ctx.fillRect(10, -5, 15, 10);
    }
    ctx.restore();
}

/**
 * INTERACTION & INVENTORY
 */
window.onmousedown = e => {
    // If clicking on UI (Hotbar/Menu), don't attack
    if(e.target.closest('.slot') || e.target.closest('.panel')) return;
    
    let wx = cam.x + e.clientX;
    let wy = cam.y + e.clientY;
    let hand = player.belt[player.beltIdx];

    world.entities.forEach((ent, i) => {
        if(Math.hypot(ent.x-wx, ent.y-wy) < 40 && Math.hypot(player.x-ent.x, player.y-ent.y) < 150) {
            let dmg = (hand && ITEMS[hand.id].dmg) || 5;
            if(hand && ITEMS[hand.id].bonus === ent.type) dmg *= 2;
            
            ent.hp -= dmg;
            ent.shake = 10;
            if(ent.type==='deer') { ent.speed = 5; ent.angle += 3.14; }

            if(ent.hp <= 0) {
                world.entities.splice(i, 1);
                giveLoot(ent.type);
            }
        }
    });
};

function giveLoot(type) {
    if(type==='tree') { addItem('wood', 50); }
    if(type==='stone') { addItem('stone', 30); }
    if(type==='iron') { addItem('iron_ore', 15); }
    if(type==='sulfur') { addItem('sulfur_ore', 15); }
    if(type==='barrel') { addItem('scrap', 2); addItem('comp', 1); }
    if(type==='crate') { addItem('scrap', 5); addItem('metal_frags', 5); }
    if(type==='deer') { addItem('fat', 3); addItem('cloth', 2); addItem('food', 2); }
}

function addItem(id, count) {
    let added = false;
    // Stack
    [player.belt, player.inv].forEach(arr => {
        for(let s of arr) if(s && s.id === id) { s.count += count; added = true; return; }
    });
    // New Slot
    if(!added) {
        for(let i=0; i<6; i++) if(!player.belt[i]) { player.belt[i] = {id, count}; added=true; break; }
    }
    if(!added) {
        for(let i=0; i<24; i++) if(!player.inv[i]) { player.inv[i] = {id, count}; added=true; break; }
    }
    
    if(added) {
        notify(`+${count} ${ITEMS[id].name}`);
        updateUI();
    } else {
        notify("–Ü–Ω–≤–µ–Ω—Ç–∞—Ä –ø–æ–≤–Ω–∏–π!");
    }
}

function notify(msg) {
    let d = document.createElement('div');
    d.className = 'note';
    d.innerText = msg;
    document.getElementById('notify-area').appendChild(d);
    setTimeout(() => d.remove(), 3000);
}

/**
 * UI & DRAG-DROP
 */
function updateUI() {
    renderGrid('hotbar', player.belt, 6, 'belt');
    renderGrid('inv-grid', player.inv, 24, 'inv');
    
    // Update Crafting
    let cl = document.getElementById('craft-list'); cl.innerHTML = '';
    RECIPES.forEach(r => {
        let d = document.createElement('div'); d.className = 'craft-row';
        let costStr = Object.keys(r.cost).map(k => `${ITEMS[k].icon}${r.cost[k]}`).join(' ');
        d.innerHTML = `<span>${ITEMS[r.id].name}</span><span style="color:#aaa; font-size:12px">${costStr}</span>`;
        d.onclick = () => craft(r);
        cl.appendChild(d);
    });
}

function craft(r) {
    for(let k in r.cost) if(countItem(k) < r.cost[k]) return notify("–ù–µ –≤–∏—Å—Ç–∞—á–∞—î —Ä–µ—Å—É—Ä—Å—ñ–≤");
    for(let k in r.cost) takeItem(k, r.cost[k]);
    addItem(r.id, r.out || 1);
}

function countItem(id) {
    let c=0; [...player.belt, ...player.inv].forEach(s=>{if(s&&s.id==id)c+=s.count}); return c;
}
function takeItem(id, n) {
    let left=n;
    [player.belt, player.inv].forEach(arr=>{
        arr.forEach((s,i)=>{
            if(left>0 && s && s.id==id) {
                let take = Math.min(left, s.count); s.count-=take; left-=take;
                if(s.count<=0) arr[i]=null;
            }
        });
    });
    updateUI();
}

function renderGrid(id, arr, size, type) {
    let el = document.getElementById(id); el.innerHTML = '';
    for(let i=0; i<size; i++) {
        let d = document.createElement('div'); d.className = 'slot';
        if(type==='belt' && i===player.beltIdx) d.classList.add('active');
        
        if(arr[i]) {
            d.innerHTML = `<div class="slot-icon">${ITEMS[arr[i].id].icon}</div><div class="slot-count">${arr[i].count}</div>`;
        }
        
        d.onmousedown = (e) => startDrag(e, i, type);
        d.onmouseup = (e) => endDrag(e, i, type);
        el.appendChild(d);
    }
}

// DRAG SYSTEM
function startDrag(e, idx, type) {
    if(e.button !== 0) return;
    let arr = type==='belt' ? player.belt : player.inv;
    if(!arr[idx]) return;
    
    dragObj = { active: true, item: arr[idx], fromIdx: idx, fromType: type };
    
    let g = document.getElementById('drag-ghost');
    g.style.display = 'flex';
    g.innerHTML = `<div class="slot active"><div class="slot-icon">${ITEMS[arr[idx].id].icon}</div></div>`;
    moveGhost(e);
}

function endDrag(e, toIdx, toType) {
    if(!dragObj.active) return;
    
    let fromArr = dragObj.fromType==='belt' ? player.belt : player.inv;
    let toArr = toType==='belt' ? player.belt : player.inv;
    
    let temp = toArr[toIdx];
    toArr[toIdx] = fromArr[dragObj.fromIdx];
    fromArr[dragObj.fromIdx] = temp;
    
    dragObj.active = false;
    document.getElementById('drag-ghost').style.display = 'none';
    updateUI();
}

window.onmousemove = e => {
    input.mx = e.clientX; input.my = e.clientY;
    if(dragObj.active) moveGhost(e);
};
window.onmouseup = () => { if(dragObj.active) { dragObj.active=false; document.getElementById('drag-ghost').style.display='none'; updateUI(); } };

function moveGhost(e) {
    let g = document.getElementById('drag-ghost');
    g.style.left = e.clientX + 'px'; g.style.top = e.clientY + 'px';
}

window.onkeydown = e => {
    if(e.code==='KeyW') input.w=1; if(e.code==='KeyS') input.s=1;
    if(e.code==='KeyA') input.a=1; if(e.code==='KeyD') input.d=1;
    if(e.code==='KeyE') {
        let m = document.getElementById('game-menu');
        m.style.display = m.style.display==='flex'?'none':'flex';
    }
    if(e.key>='1' && e.key<='6') { player.beltIdx = parseInt(e.key)-1; updateUI(); }
};
window.onkeyup = e => { if(e.code==='KeyW') input.w=0; if(e.code==='KeyS') input.s=0; if(e.code==='KeyA') input.a=0; if(e.code==='KeyD') input.d=0; };
function resize() { cvs.width=window.innerWidth; cvs.height=window.innerHeight; }
window.onresize = resize;

</script>
</body>
</html>
